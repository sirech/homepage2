{"componentChunkName":"component---src-templates-blog-post-js","path":"/painless-json-with-kotlin-and-jackson/","result":{"data":{"site":{"siteMetadata":{"title":"Mario Fernandez","description":"This is the blog from Mario Fernandez, a Software Developer working for Meta","author":"Mario Fernandez","url":"https://hceris.com","twitter":"@sirech"}},"post":{"id":"03a4ce60-7872-5299-be4a-ba3ee8f994e6","html":"<p>It seems that many backends that provide a REST API end up being glorified proxies that move <a href=\"https://www.json.org/\" target=\"_blank\" rel=\"noopener noreferrer\">JSON</a> from one place to another. It is especially true if you are trying to keep those backends as simple as possible (<a href=\"https://microservices.io/patterns/microservices.html\" target=\"_blank\" rel=\"noopener noreferrer\">Microservices</a> anyone?). Having the right tools to parse and produce JSON can thus make a big impact in keeping the code tidy and compact. I want to talk about my experience using <a href=\"https://kotlinlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kotlin</a> and <a href=\"https://github.com/FasterXML/jackson\" target=\"_blank\" rel=\"noopener noreferrer\">Jackson</a> for this.</p>\n<!--more-->\n<p>I remember that dealing with JSON in Java used to be pretty painful back in the day, as you had to write a ton of code to map objects. That is what initially led me to use <a href=\"https://www.ruby-lang.org/en/\" target=\"_blank\" rel=\"noopener noreferrer\">Ruby</a>. Things have changed a lot (for the better!) since then. Nowadays, using <em>Kotlin</em> and <em>Jackson</em> you can deal with JSON with minimal effort. <em>Jackson</em> is a mighty library, but you can get lost easily. I have a bunch of examples showing how to parse different classes, plus some code to integrate it into your workflow. In this case, I will be using <a href=\"https://spring.io/\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot</a>.</p>\n<h3>Serialize/Deserialize</h3>\n<p>We will be using <a href=\"https://kotlinlang.org/docs/reference/data-classes.html\" target=\"_blank\" rel=\"noopener noreferrer\">data classes</a> to represent the entities that will get converted to a from JSON. They are the equivalent of using the <a href=\"https://projectlombok.org/features/Value\" target=\"_blank\" rel=\"noopener noreferrer\">@Value</a> annotation in <em>Lombok</em>, with first-class support from the language. They are immutable (yay!) and have convenience methods like <code class=\"language-text\">equals</code> and <code class=\"language-text\">toString</code> out of the box.</p>\n<p>You can use an <a href=\"https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html\" target=\"_blank\" rel=\"noopener noreferrer\">ObjectMapper</a> to do the parsing, although you can configure <em>SpringBoot</em> to do it mostly automatically, which I will show later. I have a <code class=\"language-text\">User</code> entity with two fields that I want to convert to JSON and back.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String<span class=\"token punctuation\">,</span> <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">fun</span> User<span class=\"token punctuation\">.</span><span class=\"token function\">toJson</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token function\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">writeValueAsString</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">fun</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">toUser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> User <span class=\"token operator\">=</span> <span class=\"token function\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">readValue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>For simple cases, just defining the data class is enough, as long as you have the <a href=\"https://github.com/FasterXML/jackson-module-kotlin\" target=\"_blank\" rel=\"noopener noreferrer\">right module</a>. There are a bunch of extra configurations that you can do on top of it, though. Many of them can be controlled with annotations, which make the code a lot more compact. Abusing them will turn your code into an unmaintainable mess, though.</p>\n<h4>Nullability</h4>\n<p>If some of the fields are optional, you provide default values.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"\"</span></span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>You can also allow them to be <code class=\"language-text\">null</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String<span class=\"token operator\">?</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>not doing anything will make the parsing fail with an exception, which I find a good thing.</p>\n<h4>Aliasing</h4>\n<p>If you are parsing your object from a different source that uses different attribute names, but still want to keep a <em>canonical</em> representation, <code class=\"language-text\">@JsonAlias</code> is your friend.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>\n  <span class=\"token annotation builtin\">@JsonAlias</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"userId\"</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>this will correctly parse something like</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"userId\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"123\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h4>Ignore properties</h4>\n<p>Maybe you are parsing an object with a ton of fields that you don’t need. If you are not going to use it in your code, you really should avoid adding them, as that makes it harder to understand what is needed and what is not. <code class=\"language-text\">@JsonIgnoreProperties</code> can be used for this.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@JsonIgnoreProperties</span><span class=\"token punctuation\">(</span>ignoreUnknown <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>Different representations</h4>\n<p>If your backend is acting as a proxy, you will be reading your data from somewhere and passing it to your client. In this case, you might want to skip some fields in the serialization to give your client precisely the fields it needs. You can accomplish this by customizing the access property.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> String <span class=\"token operator\">=</span> <span class=\"token string-literal singleline\"><span class=\"token string\">\"\"</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token annotation builtin\">@JsonProperty</span><span class=\"token punctuation\">(</span>access <span class=\"token operator\">=</span> JsonProperty<span class=\"token punctuation\">.</span>Access<span class=\"token punctuation\">.</span>WRITE_ONLY<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>The serialization of this object won’t contain the <code class=\"language-text\">age</code>, but it is available in our code. This approach does not scale that well, however. If you find that you have two different representations of the same entity and are adding a ton of annotations to use one class, it’s probably better to split it into two distinct classes and provide a method one into the other.</p>\n<p>This underscores an important point. You don’t need to use annotations and implicit conversions for everything. In some places having dedicated converters is just more readable, more so if you want to attach some logic to that process.</p>\n<h4>And if you want more…</h4>\n<p>This article shows just a small part of what is possible to do. You can control every aspect of the serialization/deserialization process. Have a look at <a href=\"https://www.baeldung.com/jackson-annotations\" target=\"_blank\" rel=\"noopener noreferrer\">this post</a> if you want to know about other options.</p>\n<hr>\n<h3>Getting away from untyped strings</h3>\n<p>In JSON you tend to use strings to represent many entities. Any id type like a user id, or something like a language code, for example. I prefer mapping them to dedicated classes in my code. I’ve seen many bugs where the wrong entity is used when that could be prevented directly by the compiler. Taking a <code class=\"language-text\">UserId</code> as an example, I like to model it as follows:</p>\n<ul>\n<li>It should be an immutable data class</li>\n<li>It should not force a change in the structure of the JSON (i.e., no nesting)</li>\n<li>Serialize/Deserialize should work out of the box</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">UserId</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">private</span> <span class=\"token keyword\">val</span> value<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">companion</span> <span class=\"token keyword\">object</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation builtin\">@JvmStatic</span>\n        <span class=\"token annotation builtin\">@JsonCreator</span>\n        <span class=\"token keyword\">fun</span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token function\">UserId</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">toLowerCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation builtin\">@JsonValue</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> value\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>By using a data class, we get an immutable object that represents this entity. We can do relatively little with it. In fact, we don’t even want access to the internal fields. We are going to compare instances directly, and if we need to get a string representation, we’ll do that through the <code class=\"language-text\">toString</code> method.</p>\n<p>The serialization happens through the <code class=\"language-text\">@JsonValue</code> annotation, where we use the value directly. If we modify our <code class=\"language-text\">User</code> class that we have been using before, it will look like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">data</span> <span class=\"token keyword\">class</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">val</span> id<span class=\"token operator\">:</span> UserId<span class=\"token punctuation\">,</span> <span class=\"token keyword\">val</span> age<span class=\"token operator\">:</span> Int<span class=\"token punctuation\">)</span></code></pre></div>\n<p>That class serializes to this JSON</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"123\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"age\"</span><span class=\"token operator\">:</span> <span class=\"token number\">20</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That representation matches how most clients (especially a frontend) would expect this structure to look like, without sacrificing any safety in the backend.</p>\n<p>The deserialization happens automatically. However, I like to define a static constructor (using the <code class=\"language-text\">@JvmStatic</code> and <code class=\"language-text\">@JsonCreator</code> annotations) so that I can do things like sanitizing the input before generating my instance. This helps to make sure our models are in a consistent state.</p>\n<p>Since Kotlin 1.3, a new concept called <a href=\"https://kotlinlang.org/docs/reference/inline-classes.html\" target=\"_blank\" rel=\"noopener noreferrer\">inline classes</a> has been introduced, which might match better with this use case. Jackson has some trouble deserializing it properly in nested objects as of 16/06/19, so I could not replace my data classes with it so far. There is an <a href=\"https://github.com/FasterXML/jackson-module-kotlin/issues/199\" target=\"_blank\" rel=\"noopener noreferrer\">open issue in Github</a> to follow.</p>\n<hr>\n<h3>SpringBoot integration</h3>\n<p>Here we get the last piece of the puzzle. We can manually use an <code class=\"language-text\">ObjectMapper</code> and convert things explicitly. It is much easier if that happens on its own. The good news is that there is not much to do here other than adding the <a href=\"https://github.com/FasterXML/jackson-module-kotlin\" target=\"_blank\" rel=\"noopener noreferrer\">jackson-module-kotlin</a> as a dependency:</p>\n<div class=\"gatsby-highlight\" data-language=\"gradle\"><pre class=\"language-gradle\"><code class=\"language-gradle\"><span class=\"token keyword\">implementation</span><span class=\"token punctuation\">(</span><span class=\"token interpolation-string\"><span class=\"token string\">\"com.fasterxml.jackson.module:jackson-module-kotlin:</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token expression\">jacksonVersion</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">\"</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>If you are using the latest versions of everything, that will be enough. If the spring magic does not happen on its own (spring does a lot of magic that I don’t quite understand), you can do it manually. You can use a <code class=\"language-text\">@Configuration</code> so that your controllers can map to and from JSON automatically.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Configuration</span>\n<span class=\"token keyword\">class</span> JacksonConfiguration <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@Bean</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">mappingJackson2HttpMessageConverter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> MappingJackson2HttpMessageConverter <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">MappingJackson2HttpMessageConverter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>objectMapper <span class=\"token operator\">=</span> <span class=\"token function\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">registerModule</span><span class=\"token punctuation\">(</span><span class=\"token function\">KotlinModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>if you are making REST request to another service, you can build a custom <code class=\"language-text\">RestTemplate</code> doing the same:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">open</span> <span class=\"token keyword\">class</span> <span class=\"token function\">DefaultRestTemplate</span><span class=\"token punctuation\">(</span>baseUrl<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n        <span class=\"token function\">RestTemplate</span><span class=\"token punctuation\">(</span><span class=\"token function\">HttpComponentsClientHttpRequestFactory</span><span class=\"token punctuation\">(</span>\n                HttpClientBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">useSystemProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">init</span> <span class=\"token punctuation\">{</span>\n        uriTemplateHandler <span class=\"token operator\">=</span> <span class=\"token function\">DefaultUriBuilderFactory</span><span class=\"token punctuation\">(</span>baseUrl<span class=\"token punctuation\">)</span>\n        messageConverters <span class=\"token operator\">=</span> <span class=\"token function\">jacksonConverter</span><span class=\"token punctuation\">(</span>messageConverters<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">jacksonConverter</span><span class=\"token punctuation\">(</span>converters<span class=\"token operator\">:</span> MutableList<span class=\"token operator\">&lt;</span>HttpMessageConverter<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>HttpMessageConverter<span class=\"token operator\">&lt;</span><span class=\"token operator\">*</span><span class=\"token operator\">></span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> jsonConverter <span class=\"token operator\">=</span> <span class=\"token function\">MappingJackson2HttpMessageConverter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        jsonConverter<span class=\"token punctuation\">.</span>objectMapper <span class=\"token operator\">=</span> <span class=\"token function\">jacksonObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">registerModule</span><span class=\"token punctuation\">(</span><span class=\"token function\">KotlinModule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n        converters<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>jsonConverter<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> converters\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Again, all this should happen by just adding the library to the classpath. Use this as a fallback in case that does not work for some reason. Also, this template can be extended to use a base URL, receive environment variables (to include the keystore for instance), or automatically add certain headers to your requests.</p>\n<h4>PathVariables are not JSON</h4>\n<p>Now that we are waist-deep in automated JSON mapping, I’m getting ambitious. As mentioned above, we are no longer using plain strings but proper domain classes. Let’s say you have a route like <code class=\"language-text\">GET /users/:userId</code>. The controller would look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@RestController</span>\n<span class=\"token annotation builtin\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"/users\"</span></span><span class=\"token punctuation\">,</span> produces <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>MediaType<span class=\"token punctuation\">.</span>APPLICATION_JSON_VALUE<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> HelloController <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"{userId}\"</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fun</span> <span class=\"token function\">user</span><span class=\"token punctuation\">(</span><span class=\"token annotation builtin\">@PathVariable</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"userId\"</span></span><span class=\"token punctuation\">)</span> userId<span class=\"token operator\">:</span> UserId<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ResponseEntity<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If you send a request to this route, the <code class=\"language-text\">userId</code> will get parsed automatically, but our custom <code class=\"language-text\">create</code> method won’t get called, because this is a URL, not JSON. We didn’t come this far to start parsing strings manually again. Let’s fix this by using a custom converter.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Configuration</span>\n<span class=\"token keyword\">class</span> ConverterConfiguration <span class=\"token operator\">:</span> WebMvcConfigurer <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">addFormatters</span><span class=\"token punctuation\">(</span>registry<span class=\"token operator\">:</span> FormatterRegistry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        registry<span class=\"token punctuation\">.</span><span class=\"token function\">addConverter</span><span class=\"token punctuation\">(</span><span class=\"token function\">userId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">userId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Converter<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> UserId<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> Converter<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> UserId<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span> source <span class=\"token operator\">-></span> UserId<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>That’s it. Now we can be sure that those pesky strings are not floating through our app at any point in the flow of a request.</p>\n<h3>Summary</h3>\n<p>Jackson is a very powerful library, and to be honest, you can overdo it with all the annotations. If you use them judiciously, though, working with JSON becomes very easy while keeping a good amount of type safety in the process. For testing, this goes well with <a href=\"https://hceris.com/recording-apis-with-wiremock/\" target=\"_blank\" rel=\"noopener noreferrer\">recorded APIs using WireMock</a>.</p>\n<p><em>EDIT 25/12/2019:</em> Grammar review</p>","frontmatter":{"layout":"post","title":"Painless JSON with Kotlin and jackson","path":"/painless-json-with-kotlin-and-jackson/","categories":["Kotlin","JSON","Jackson","REST","SpringBoot"],"date":"2019/06/16","draft":false,"description":"Backends that provide a REST API or consume other APIs have to deal with JSON quite a lot. Luckily combining Kotlin and Jackson makes it a breeze","canonical":null,"image":null}},"related":{"nodes":[{"frontmatter":{"title":"Either Types as an alternative to throwing exceptions in Kotlin","path":"/kotlin-either-types-instead-of-exceptions/","date":"2020/01/09"}},{"frontmatter":{"title":"Descriptive assertions in Kotlin for clearer tests","path":"/descriptive-assertions-in-kotlin/","date":"2019/09/28"}},{"frontmatter":{"title":"Book Review: Kotlin in Action","path":"/book-review-kotlin-in-action/","date":"2020/06/28"}}]},"previous":{"frontmatter":{"title":"Dockerizing a JVM app with CircleCI","path":"/dockerizing-a-jvm-app-with-circleci/","date":"2019/07/15"}},"next":{"frontmatter":{"title":"Custom Components in Formik","path":"/custom-components-in-formik/","date":"2019/08/15"}}},"pageContext":{"related":["/kotlin-either-types-instead-of-exceptions/","/descriptive-assertions-in-kotlin/","/book-review-kotlin-in-action/"],"previous":"/dockerizing-a-jvm-app-with-circleci/","next":"/custom-components-in-formik/"}},"staticQueryHashes":[],"slicesMap":{}}