{"componentChunkName":"component---src-templates-blog-post-js","path":"/the-humble-extract-method/","result":{"data":{"site":{"siteMetadata":{"title":"Mario Fernandez","description":"This is the blog from Mario Fernandez, a Software Developer working for Meta","author":"Mario Fernandez","url":"https://hceris.com","twitter":"@sirech"}},"post":{"id":"7c957250-3360-5ce8-b464-4ef910e3e029","html":"<p>After reviewing a lot of code in the past couple of months, I’ve realized that I regularly leave comments like this one:</p>\n<blockquote>\n<p>Can we break this down into smaller pieces?</p>\n</blockquote>\n<figure class=\"figure figure--right\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 750px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/50ecbbe08d280c18e51685dc01032100/bfe25/cover.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 65.42553191489361%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAABzCiVD//EABYQAAMAAAAAAAAAAAAAAAAAAAEQIP/aAAgBAQABBQKAv//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EAB0QAAICAQUAAAAAAAAAAAAAAAABESFREGFxkaH/2gAIAQEAAT8hjY4RWH3pZwQ8+H//2gAMAwEAAgADAAAAEOsf/8QAFxEBAAMAAAAAAAAAAAAAAAAAAAERYf/aAAgBAwEBPxCMU//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EFf/xAAcEAEAAwACAwAAAAAAAAAAAAABABEhQVFhcZH/2gAIAQEAAT8QBeuji5WKh9YFNb1GiPcLsrySjKR//9k='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Refactoring\" title=\"\" src=\"/static/50ecbbe08d280c18e51685dc01032100/acb04/cover.jpg\" srcset=\"/static/50ecbbe08d280c18e51685dc01032100/bc01b/cover.jpg 188w,\n/static/50ecbbe08d280c18e51685dc01032100/bf173/cover.jpg 375w,\n/static/50ecbbe08d280c18e51685dc01032100/acb04/cover.jpg 750w,\n/static/50ecbbe08d280c18e51685dc01032100/ec605/cover.jpg 1125w,\n/static/50ecbbe08d280c18e51685dc01032100/bfe25/cover.jpg 1422w\" sizes=\"(max-width: 750px) 100vw, 750px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</figure>\n<p>Turns out, I like to advocate for shorter methods. Is this the right thing to pay attention to? I think so. I strongly believe that breaking down code is often the most cost-effective way to increase maintainability.</p>\n<p>For that, the best alternative is <em>extracting smaller methods</em>. It’s easy and works consistently. It should be part of every developer’s toolkit.</p>\n<p>In this article, I’m writing about the simple yet powerful extract method refactoring.</p>\n<h2>What Is Extract Method, Exactly?</h2>\n<p><em>Extract method</em> is <a href=\"https://refactoring.com/catalog/extractFunction.html\" target=\"_blank\" rel=\"noopener noreferrer\">a refactoring</a> where you move a code fragment to a separate function with a name that describes its purpose. Consider this snippet:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">splitNumbers</span><span class=\"token punctuation\">(</span>source<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> split <span class=\"token operator\">=</span> source<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\",\"</span></span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\">// convert each string to a number</span>\n    <span class=\"token keyword\">val</span> numbers <span class=\"token operator\">=</span> split<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> str <span class=\"token operator\">-></span>\n        str<span class=\"token punctuation\">.</span><span class=\"token function\">toInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> numbers\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This is too small to truly benefit from breaking it down, so bear with me for the sake of the example. Anyway, there’s a section that converts a string to a number. It’s a prime candidate for extraction:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">fun</span> <span class=\"token function\">splitNumbers</span><span class=\"token punctuation\">(</span>source<span class=\"token operator\">:</span> String<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> split <span class=\"token operator\">=</span> source<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\",\"</span></span><span class=\"token punctuation\">)</span>\n    \n    <span class=\"token keyword\">val</span> numbers <span class=\"token operator\">=</span> <span class=\"token function\">convertStringToNumber</span><span class=\"token punctuation\">(</span>split<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> numbers\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">fun</span> <span class=\"token function\">convertStringToNumber</span><span class=\"token punctuation\">(</span>list<span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> List<span class=\"token operator\">&lt;</span>Int<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> str <span class=\"token operator\">-></span>\n        str<span class=\"token punctuation\">.</span><span class=\"token function\">toInt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>There it is! We now have a proper submethod instead of an inline comment. For a more realistic scenario, imagine this was a hundred lines long instead of five. The good thing is, the approach would work the exact same way. Moreover, you can repeat the procedure and break down the new methods.</p>\n<p>All in all, this refactoring is pretty straightforward. In fact, it’s been supported by IDEs like <a href=\"https://www.jetbrains.com/help/idea/extract-method.html\" target=\"_blank\" rel=\"noopener noreferrer\">IntelliJ</a> for basically forever. And yet! Despite its simplicity, this humble change brings quite a lot of value. Let’s talk about its benefits.</p>\n<h2>Shorter Methods Improve Readability</h2>\n<p>The most obvious outcome of using <em>Extract Method</em> is that it makes methods <strong>short</strong>. Is that a good thing, though?</p>\n<p>Yes! Let me argue why. Shortening methods is necessary to get them to do one thing only (also known as the <a href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\" target=\"_blank\" rel=\"noopener noreferrer\">Single Responsibility Principle</a>). Methods that do one thing are generally less complex. They require less knowledge about the surrounding context.</p>\n<p>When you navigate a big codebase, you can’t keep every detail in your head. If you have short, single-purpose methods you can tune out some complexity and focus on one part at a time. That, in my mind, leads to a massive readability boost.</p>\n<p>One argument I’ve heard against extracting methods is that it’s easier to understand code if it’s all in the same place. I find the reasoning unsatisfying. In my opinion, it assumes you’ll be able to zoom in and focus on the relevant parts as you read through a possibly massive block. To do that, you need to be pretty familiar with the codebase already. Otherwise, you’re going to struggle.</p>\n<p>In my view, a more sustainable alternative is to rely on abstract methods that hide implementation details. That way, even if your understanding is incomplete you’ll still be effective. Note that this only holds true if the abstractions are <em>good</em>. If the division doesn’t make any sense, you’ll be without a doubt worse off.</p>\n<p>How short is short enough? That’s a matter of debate and preference. Hear <a href=\"https://www.oreilly.com/library/view/clean-code-a/9780136083238/\" target=\"_blank\" rel=\"noopener noreferrer\">Uncle Bob</a> for some guidance:</p>\n<blockquote>\n<p>My rule is “extract till you drop”.  A function is too big if I can meaningfully extract another function from it.</p>\n</blockquote>\n<h2>Extracting Methods is an Opportunity for Good Naming</h2>\n<p>Naming is hard. And yet, without good names extracting methods isn’t worth it. Even if the abstraction is good, a bad name makes it inaccessible. Thus, good naming is crucial for readability.</p>\n<p>A name that describes the method’s purpose serves as lightweight documentation. Documentation that’s supported by the language, unlike comments. Automated tooling can find and change methods in a way that’s usually impossible in ad-hoc comments.</p>\n<p>If you’re struggling to find a name for an extracted method, it can be a sign of two things:</p>\n<ul>\n<li>An unclear boundary, and thus a fuzzy responsibility. That makes it hard to find a proper name</li>\n<li>The method is still too big and needs to be split further</li>\n</ul>\n<h2>Not Bad, and There Is More</h2>\n<p>The combination of smaller methods and better names reduces cognitive load. Each method serves as a small reusable abstraction. For instance, something as typical as iterating over a list to apply a function to every element:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> input <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> mutableListOf<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>item <span class=\"token keyword\">in</span> input<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">return</span> result</code></pre></div>\n<p>A better alternative is to use a higher-level abstraction, in this case, <code class=\"language-text\">map</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> input <span class=\"token operator\">=</span> <span class=\"token function\">listOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">val</span> result <span class=\"token operator\">=</span> input<span class=\"token punctuation\">.</span><span class=\"token function\">map</span> <span class=\"token punctuation\">{</span> it<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">return</span> result</code></pre></div>\n<p>Using <code class=\"language-text\">map</code> encapsulates the implementation and lets you focus on what you want to express.</p>\n<p>Anyhow. While shorter methods and better names are the big two aspects, other considerations speak for using this refactoring.</p>\n<h3>Nesting Is Another form of Complexity</h3>\n<p>Excessive length isn’t the only way complexity creeps in. Code that’s nested multiple layers deep is as hard to read as an overly long piece of code. It can hide bugs as you inadvertently put things in the wrong scope.</p>\n<p>Luckily, extracting methods reduces nesting the same way that it reduces length.</p>\n<h3>Small Methods Reduce Coupling</h3>\n<p>Dependencies make it harder to reason about code. They make it harder to change as well.</p>\n<p>Suppose you have a massive method. There are plenty of local variables capturing intermediate results. While they provide an opportunity for meaningful names, they lack the encapsulation that methods provide. You have access to everything that happened before within the same scope, which can entangle the logic beyond salvation.</p>\n<p>Not only that, you start getting worried about unexpected changes. You can’t be sure that the variable wasn’t modified unless you painstakingly go through the whole logic. Doubly so in languages that don’t allow read-only variables.</p>\n<h3>What About Testability?</h3>\n<figure class=\"figure figure--left\">\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 284px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/2b283964c3da3e9d74ce30511601be03/2afb1/working-effectively.jpg\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 131.91489361702128%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAaABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAH/xAAXAQADAQAAAAAAAAAAAAAAAAAAAgMB/9oADAMBAAIQAxAAAAGDp2Vc5EohWTC5hDT/xAAdEAEAAgICAwAAAAAAAAAAAAABAAIDERITECEy/9oACAEBAAEFAukJXHqXoj3cpzZbILTellvqp7A8f//EABgRAAIDAAAAAAAAAAAAAAAAAAABEBES/9oACAEDAQE/AXkpT//EABgRAAIDAAAAAAAAAAAAAAAAAAABEBES/9oACAECAQE/AVotz//EAB8QAAIBAgcAAAAAAAAAAAAAAAABIQIQESIxMkGBof/aAAgBAQAGPwLQxUE1ohGx2hUmX046Hf8A/8QAHBAAAgMBAQEBAAAAAAAAAAAAAREAITFRQYHB/9oACAEBAAE/ISIjd9gdfFzQ03Ly8rUJ3+gjnDHAfuy1ITDgn+EAXAeRQ0Nh0z//2gAMAwEAAgADAAAAEEsEjv/EABkRAAIDAQAAAAAAAAAAAAAAAAABEBEhMf/aAAgBAwEBPxC3MKeCcf/EABgRAAIDAAAAAAAAAAAAAAAAAAABEEFR/9oACAECAQE/ELDUacf/xAAdEAEBAAMBAQADAAAAAAAAAAABEQAhQWFRcYGh/9oACAEBAAE/EF1h2SL9xYACRNreR1rIkQERZfwZsQXeM9cTYFAt3k/RiAn3k64HUpVYLeK0EY2EN9MIxDpnhgWqdnmIo23PDP7nP//Z'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Working Effectively with Legacy Code\" title=\"\" src=\"/static/2b283964c3da3e9d74ce30511601be03/2afb1/working-effectively.jpg\" srcset=\"/static/2b283964c3da3e9d74ce30511601be03/bc01b/working-effectively.jpg 188w,\n/static/2b283964c3da3e9d74ce30511601be03/2afb1/working-effectively.jpg 284w\" sizes=\"(max-width: 284px) 100vw, 284px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span>\n</figure>\n<p>And lastly, we come to testability. Does extracting methods improve testability? You could argue it doesn’t, as you should have your tests ready <em>before</em> you perform the refactoring.</p>\n<p>However! Reality isn’t always so kind. You might face a huge, gnarly class that lacks tests. Writing tests might prove impossible unless you make the problem more manageable.</p>\n<p>As described in the book <a href=\"../book-review-working-effectively-with-legacy-code/\">Working Effectively with Legacy Code</a>, extracting methods allows you to break down smaller pieces. At some point, they become small enough that you can write some tests for them.</p>\n<p>It’s not pretty, but it gets the job done. Much better than the alternative of not really knowing if your changes will break something.</p>\n<h2>Notice I Didn’t Talk about Reuse</h2>\n<p>I haven’t mentioned reusability throughout the article. It is, in fact, not the primary goal of <em>Extract Method</em>.</p>\n<p>A smaller auxiliary method is valuable even if we only use it once. Making code more readable is already a significant benefit, worth doing on its own. If that method encapsulates a reusable abstraction, that’s a welcome benefit. But it’s not something to force or expect.</p>\n<h2>Is Extracting Methods Worth The Effort?</h2>\n<p>In any big codebase, the code developers write lives for a long time. Often, it’s still there while the original developers moved somewhere else.</p>\n<p>Meanwhile, new developers will read it many times and try to figure out what it does. Capturing the context of why a decision happened is hard, so these poor developers are left without context. By investing some effort into making it more readable you’ll make their life easier.</p>\n<p>Not that you should overdo it, though. An endless collection of one-liners isn’t an improvement, either. Aim for methods that stand on their own and have one purpose. That’s a reasonable guideline to follow.</p>","frontmatter":{"layout":"post","title":"The Humble Extract Method","path":"/the-humble-extract-method/","categories":["Practices","Software Engineering","Refactoring"],"date":"2023/02/27","draft":false,"description":"The extract method refactoring is a low-cost, high-impact tool to increase maintainability in your code. Let's talk about its benefits","canonical":null,"image":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#181818","images":{"fallback":{"src":"/static/50ecbbe08d280c18e51685dc01032100/29171/cover.jpg","srcSet":"/static/50ecbbe08d280c18e51685dc01032100/f4cec/cover.jpg 188w,\n/static/50ecbbe08d280c18e51685dc01032100/41ec1/cover.jpg 375w,\n/static/50ecbbe08d280c18e51685dc01032100/29171/cover.jpg 750w","sizes":"(min-width: 750px) 750px, 100vw"},"sources":[{"srcSet":"/static/50ecbbe08d280c18e51685dc01032100/69758/cover.webp 188w,\n/static/50ecbbe08d280c18e51685dc01032100/9256c/cover.webp 375w,\n/static/50ecbbe08d280c18e51685dc01032100/80ff3/cover.webp 750w","type":"image/webp","sizes":"(min-width: 750px) 750px, 100vw"}]},"width":750,"height":489}}}}},"related":{"nodes":[{"frontmatter":{"title":"Book Review: Working effectively with legacy code","path":"/book-review-working-effectively-with-legacy-code/","date":"2020/11/12"}},{"frontmatter":{"title":"Why Is Refactoring Your Code Important in Agile?","path":"/why-is-refactoring-your-code-important-in-agile/","date":"2021/05/02"}},{"frontmatter":{"title":"What Is Code Duplication? A Definition and Overview","path":"/what-is-code-duplication-definition-and-overview/","date":"2021/04/18"}}]},"previous":{"frontmatter":{"title":"Book Review: Effective Remote Work","path":"/book-review-effective-remote-work/","date":"2022/11/27"}},"next":{"frontmatter":{"title":"A Method to Give Feedback","path":"/a-method-to-give-feedback/","date":"2023/08/07"}}},"pageContext":{"related":["/book-review-working-effectively-with-legacy-code/","/what-is-code-duplication-definition-and-overview/","/why-is-refactoring-your-code-important-in-agile/"],"previous":"/book-review-effective-remote-work/","next":"/a-method-to-give-feedback/"}},"staticQueryHashes":[],"slicesMap":{}}