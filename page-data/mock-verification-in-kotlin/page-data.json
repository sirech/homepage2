{"componentChunkName":"component---src-templates-blog-post-js","path":"/mock-verification-in-kotlin/","result":{"data":{"site":{"siteMetadata":{"title":"Mario Fernandez","description":"This is the blog from Mario Fernandez, a Software Developer working for Meta","author":"Mario Fernandez","url":"https://hceris.com","twitter":"@sirech"}},"post":{"id":"4d5b88d0-5449-561f-b296-b9ef4c8cd843","html":"<p>I have been working with <a href=\"https://kotlinlang.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Kotlin</a> a lot lately. It is a really awesome language. Elegant, powerful and succinct, it fixes most of the annoyances that I had with <em>Java</em>, yet it keeps a certain amount of familiarity that allows the transition from it to be very manageable.</p>\n<p>Anyhow, I found myself recently having to build a filter in <a href=\"https://spring.io/\" target=\"_blank\" rel=\"noopener noreferrer\">SpringBoot</a> that I wanted to test. For that I needed to use both a mock and verify that behavior at the same time. <em>Kotlin</em> is evolving quite fast and there are plenty of alternatives to choose from. I will show how to do this with two excellent libraries, <a href=\"https://mockk.io/\" target=\"_blank\" rel=\"noopener noreferrer\">MockK</a>, and <a href=\"https://docs.atriumlib.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Atrium</a>.</p>\n<!--more-->\n<h2>MockK and Atrium, a powerful combo</h2>\n<p>In the short time that I have been developing <em>Kotlin</em>, I’ve noticed a pattern. Whenever you need something not provided in the standard library, you tend to start by using the existing <em>Java</em> library that you are familiar with. Then, at some point, you figure out there is a native <em>Kotlin</em> library that leverages the features from the language better.</p>\n<p><a href=\"https://www.thoughtworks.com/radar/languages-and-frameworks/mockk\" target=\"_blank\" rel=\"noopener noreferrer\">MockK</a> seems to be on its way to become the defacto mocking library for <em>Kotlin</em> apps. With a syntax based heavily around lambdas, it just looks like a DSL, as you can see in this example taken directly from their page:</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token keyword\">val</span> car <span class=\"token operator\">=</span> mockk<span class=\"token operator\">&lt;</span>Car<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\nevery <span class=\"token punctuation\">{</span> car<span class=\"token punctuation\">.</span><span class=\"token function\">drive</span><span class=\"token punctuation\">(</span>Direction<span class=\"token punctuation\">.</span>NORTH<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span> returns Outcome<span class=\"token punctuation\">.</span>OK\ncar<span class=\"token punctuation\">.</span><span class=\"token function\">drive</span><span class=\"token punctuation\">(</span>Direction<span class=\"token punctuation\">.</span>NORTH<span class=\"token punctuation\">)</span> <span class=\"token comment\">// returns OK</span>\n\nverify <span class=\"token punctuation\">{</span> car<span class=\"token punctuation\">.</span><span class=\"token function\">drive</span><span class=\"token punctuation\">(</span>Direction<span class=\"token punctuation\">.</span>NORTH<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>Meanwhile, <em>Atrium</em> is less established, but after getting the recommendation from a colleague, I gave it a try. It uses <code class=\"language-text\">expect</code>, so for somebody like me who is used to <em>RSpec</em> it is already a win. Anyhow, the syntax takes some time to get used to, but it can be quite expressive. I particularly like combining it with data classes to have exactly one assertion per test instead of many.</p>\n<h2>The problem at hand</h2>\n<p>What I was trying to build was not particularly complex. I wanted to write a filter for a <em>SpringBoot</em> application that would inject some headers into the request based on some logic. All controllers would use these values transparently, without having to care about the computation. The filter looks like this.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Component</span>\n<span class=\"token keyword\">class</span> Filter <span class=\"token operator\">:</span> <span class=\"token function\">OncePerRequestFilter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation builtin\">@Autowired</span>\n    <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> processor<span class=\"token operator\">:</span> Processor\n\n    <span class=\"token keyword\">override</span> <span class=\"token keyword\">fun</span> <span class=\"token function\">doFilterInternal</span><span class=\"token punctuation\">(</span>request<span class=\"token operator\">:</span> HttpServletRequest<span class=\"token punctuation\">,</span> response<span class=\"token operator\">:</span> HttpServletResponse<span class=\"token punctuation\">,</span> filterChain<span class=\"token operator\">:</span> FilterChain<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">val</span> wrappedRequest <span class=\"token operator\">=</span> <span class=\"token function\">HttpServletRequestWrapper</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">addHeader</span><span class=\"token punctuation\">(</span>Headers<span class=\"token punctuation\">.</span>EXTRA_HEADER<span class=\"token punctuation\">,</span> processor<span class=\"token punctuation\">.</span><span class=\"token function\">process</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n\n        filterChain<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span>wrappedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I want to test two things:</p>\n<ul>\n<li>The <code class=\"language-text\">filterChain</code> should be called with my <code class=\"language-text\">wrappedRequest</code></li>\n<li>The <code class=\"language-text\">wrappedRequest</code> should have the correct header in it</li>\n</ul>\n<h3>Setting up the test</h3>\n<p>I am using <a href=\"https://junit.org/junit5/\" target=\"_blank\" rel=\"noopener noreferrer\">JUnit 5</a> for the test (Speaking of native libraries, I haven’t tried something like <a href=\"https://dzone.com/articles/testing-kotlin-with-spock-part-1-object\" target=\"_blank\" rel=\"noopener noreferrer\">Spock</a> yet). The basic setup of the test requires to set up the filter and the mocks that I need.</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@ExtendWith</span><span class=\"token punctuation\">(</span>MockKExtension<span class=\"token operator\">::</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">internal</span> <span class=\"token keyword\">class</span> FilterTest <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">val</span> request <span class=\"token operator\">=</span> <span class=\"token function\">MockHttpServletRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token annotation builtin\">@MockK</span>\n    <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> response<span class=\"token operator\">:</span> HttpServletResponse\n\n    <span class=\"token annotation builtin\">@RelaxedMockK</span>\n    <span class=\"token keyword\">lateinit</span> <span class=\"token keyword\">var</span> filterChain<span class=\"token operator\">:</span> FilterChain\n\n    <span class=\"token keyword\">val</span> filter <span class=\"token operator\">=</span> <span class=\"token function\">Filter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span> <span class=\"token punctuation\">{</span>\n        processor <span class=\"token operator\">=</span> <span class=\"token function\">ProcessorImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I am using annotations to initialize the mocks (which requires annotating the test with <code class=\"language-text\">MockKExtension</code>). My <code class=\"language-text\">filterChain</code> is a <code class=\"language-text\">RelaxedMockK</code>, which means that its methods will return a default value unless otherwise specified.</p>\n<h3>A very simple test</h3>\n<p>If I just want to check that the method is being called, I don’t really need much</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Test</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">`calls the next step in the filter`</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    filter<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> filterChain<span class=\"token punctuation\">)</span>\n    verify <span class=\"token punctuation\">{</span> filterChain<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span><span class=\"token function\">any</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Testing the wrapped request</h3>\n<p>The previous test is OK, but it is a bit bland for my taste. I want to make sure that that the <code class=\"language-text\">filterChain</code> is being called with my <code class=\"language-text\">wrappedRequest</code>, and that it contains the header I injected. This test becomes much more interesting</p>\n<div class=\"gatsby-highlight\" data-language=\"kotlin\"><pre class=\"language-kotlin\"><code class=\"language-kotlin\"><span class=\"token annotation builtin\">@Test</span>\n<span class=\"token keyword\">fun</span> <span class=\"token function\">`injects header into the request and passes it to the filter`</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    filter<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> filterChain<span class=\"token punctuation\">)</span>\n\n    slot<span class=\"token operator\">&lt;</span>ServletRequest<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">let</span> <span class=\"token punctuation\">{</span> slot <span class=\"token operator\">-></span>\n        verify <span class=\"token punctuation\">{</span> filterChain<span class=\"token punctuation\">.</span><span class=\"token function\">doFilter</span><span class=\"token punctuation\">(</span><span class=\"token function\">capture</span><span class=\"token punctuation\">(</span>slot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">expect</span><span class=\"token punctuation\">(</span>slot<span class=\"token punctuation\">.</span>captured<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>isA<span class=\"token operator\">&lt;</span>HttpServletRequestWrapper<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">expect</span><span class=\"token punctuation\">(</span>subject<span class=\"token punctuation\">.</span><span class=\"token function\">getHeader</span><span class=\"token punctuation\">(</span>Headers<span class=\"token punctuation\">.</span>EXTRA_HEADER<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toBe</span><span class=\"token punctuation\">(</span><span class=\"token string-literal singleline\"><span class=\"token string\">\"value\"</span></span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Not so simple anymore! Let’s break it down.</p>\n<p>First we are capturing the first argument for <code class=\"language-text\">doFilter</code> (i.e: the wrapped request). We are creating a new slot by doing <code class=\"language-text\">slot&lt;ServletRequest></code>, and capturing it by passing it in the <code class=\"language-text\">verify</code> block by doing <code class=\"language-text\">capture(slot)</code>. The <code class=\"language-text\">let</code> block wrapping everything is there so that we don’t need an extra local variable (and to feel more kotlin-y inside).</p>\n<p>After all this <code class=\"language-text\">slot.captured</code> contains the <code class=\"language-text\">wrappedRequest</code> that we created in the filter. Here is where <em>Atrium</em> can shine. We use <code class=\"language-text\">isA</code> first to check that the request is of the right type. Then inside the block <code class=\"language-text\">subject</code> is the casted type, where we finally check that our header is there.</p>\n<h2>Summary</h2>\n<p>With this our small filter can be tested properly and with very little overhead. I am no <em>Kotlin</em> connoisseur, but the syntax of both <em>MockK</em> and <em>Atrium</em> feels quite elegant to me, once you wrap your head around it. I think this is a good starting point to build better and better tests without a ton of boilerplate code.</p>","frontmatter":{"layout":"post","title":"Mock verification in Kotlin using MockK and Atrium","path":"/mock-verification-in-kotlin/","categories":["Kotlin","Testing","MockK","SpringBoot","Atrium"],"date":"2019/05/27","draft":false,"description":"When working with Kotlin you might need to build some non trivial mocks that need to be verified. Here is how to do it by combining MockK and Atrium","canonical":null,"image":null}},"related":{"nodes":[{"frontmatter":{"title":"Painless JSON with Kotlin and jackson","path":"/painless-json-with-kotlin-and-jackson/","date":"2019/06/16"}},{"frontmatter":{"title":"Descriptive assertions in Kotlin for clearer tests","path":"/descriptive-assertions-in-kotlin/","date":"2019/09/28"}},{"frontmatter":{"title":"Either Types as an alternative to throwing exceptions in Kotlin","path":"/kotlin-either-types-instead-of-exceptions/","date":"2020/01/09"}}]},"previous":{"frontmatter":{"title":"An overview of IAM in AWS","path":"/aws-iam-an-overview/","date":"2019/03/09"}},"next":{"frontmatter":{"title":"Painless JSON with Kotlin and jackson","path":"/painless-json-with-kotlin-and-jackson/","date":"2019/06/16"}}},"pageContext":{"related":["/kotlin-either-types-instead-of-exceptions/","/painless-json-with-kotlin-and-jackson/","/descriptive-assertions-in-kotlin/"],"previous":"/aws-iam-an-overview/","next":"/painless-json-with-kotlin-and-jackson/"}},"staticQueryHashes":[],"slicesMap":{}}