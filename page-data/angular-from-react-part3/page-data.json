{"componentChunkName":"component---src-templates-blog-post-js","path":"/angular-from-react-part3/","result":{"data":{"site":{"siteMetadata":{"title":"Mario Fernandez","description":"This is the blog from Mario Fernandez, a Software Developer working for Meta","author":"Mario Fernandez","url":"https://hceris.com","twitter":"@sirech"}},"post":{"id":"6782f6a8-9927-5678-85b4-927d4877aacc","html":"<div class=\"guide\">\n<h3>Angular Series</h3>\n<ul>\n<li><a href=\"../angular-from-react-part1/\">Part 1 - Bootstrapping and TypeScript</a></li>\n<li><a href=\"../angular-from-react-part2/\">Part 2 - Testing</a></li>\n<li><a href=\"../angular-from-react-part3/\"><strong>Part 3 - State Management</strong></a></li>\n</ul>\n</div>\n<p>When building a complex application, it is really important to think about how the data flows through it. I remember, back in the <a href=\"https://jquery.com/\" target=\"_blank\" rel=\"noopener noreferrer\">jQuery</a> days, having code that would modify multiple unrelated parts of the page. It is a good thing we did not do a lot of unit testing back then, because that code was basically impossible to test.</p>\n<p>Still suffering PTSD from that, I instantly became a fan of <a href=\"https://redux.js.org/\" target=\"_blank\" rel=\"noopener noreferrer\">redux</a>, once I actually manage to understand how it works. Anyways, the <a href=\"https://redux.js.org/basics/data-flow\" target=\"_blank\" rel=\"noopener noreferrer\">unidirectional flow pattern</a> is a very good way to alter the state of an application in a predictable way.</p>\n<p><em>Angular</em> has a bunch of different options to handle state. The project I am working on did not have somebody with a lot of experience in the matter when it was being set up, so I have seen many attempts to do this, stored in its history. Some of them failed quite spectacularly at making our life easier. I am still looking for a good way of treating state in <em>Angular</em>, but at least I have learned a couple of lessons (the hard way) that I want to share. This are some examples of ways of modeling state in <em>Angular</em> that I have seen and used.</p>\n<!--more-->\n<h2>Input/Output</h2>\n<p><a href=\"https://angular.io/guide/component-interaction#pass-data-from-parent-to-child-with-input-binding\" target=\"_blank\" rel=\"noopener noreferrer\">Input/Output</a> is basically the equivalent of <a href=\"https://reactjs.org/docs/components-and-props.html\" target=\"_blank\" rel=\"noopener noreferrer\">props in React</a>. The state is not kept in the component, but injected from the outside. Whenever the component needs to trigger a notification, an <em>Output</em> can be used with a callback.</p>\n<p>This is a fine way to manage state and create mostly components that are representational and donâ€™t manage their own state. It has one drawback, shared with <em>props</em>, which is that if your component hierarchy is very deep you can end up having a lot of components passing data and callbacks up and down, even if there are not using it themselves.</p>\n<p>I really like seeing small and simple components where you instantly understand what data is needed, and which actions are being triggered from it.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleComponent</span> <span class=\"token punctuation\">{</span>\n  @<span class=\"token function\">Input</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> selectedDate<span class=\"token operator\">:</span> Date<span class=\"token punctuation\">;</span>\n  @<span class=\"token function\">Output</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> onJump <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EventEmitter</span><span class=\"token operator\">&lt;</span>Date<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">jumpBack</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">date</span><span class=\"token operator\">:</span> Date</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>onJumpto<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span>date<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Now, the state has to be managed <em>somewhere</em>. At least one component needs to take on that responsibility. But if most components do not need to care about state, it becomes a lot easier to reason about them, and to, dare I say, <strong>reuse</strong> them.</p>\n<h2>ViewChild</h2>\n<p>A <a href=\"https://angular.io/api/core/ViewChild\" target=\"_blank\" rel=\"noopener noreferrer\">ViewChild</a> gives a reference to a child component to a parent component, which allows it to break every rule in unidirectional flow and call methods directly. It is extremely easy to misue it to build a web of deeply connected components that you will never be able to refactor. You can do something like this</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// Bad idea</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Evil</span> <span class=\"token punctuation\">{</span>\n  @<span class=\"token function\">ViewChild</span><span class=\"token punctuation\">(</span>PoorChildrenComponent<span class=\"token punctuation\">)</span>\n  <span class=\"token literal-property property\">sayGoodbyeToEncapsulation</span><span class=\"token operator\">:</span> PoorChildrenComponent<span class=\"token punctuation\">;</span> \n\n  <span class=\"token function\">ngOnInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sayGoodbyeToEncapsulation<span class=\"token punctuation\">.</span><span class=\"token function\">changeStuffExternally</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>I am sure there is a reason for this feature, and a proper way to use it, but I have seen it mostly to tightly couple components together. Until I see a compelling reason to use this feature that does not lead to broken designs, I do not see a place for this feature outside of component tests.</p>\n<h2>Nested Forms</h2>\n<p>Another way to create a somewhat hidden connection between components are <a href=\"https://angular.io/guide/reactive-forms\" target=\"_blank\" rel=\"noopener noreferrer\">nested forms</a>. The idea for nesting forms as far as I understand it is to combine multiple forms across different components into one form that can be validated and submitted as a unit. That sure sounds good. However, without discipline you can do things like change the values of the form from very far away.</p>\n<p>In fact, using this pattern without really thinking about how the state is updated led to some lost updates, which ended up being solved by plastering the code with <code class=\"language-text\">detectChanges</code>. Debugging that problem was no fun at all.</p>\n<h2>Data Services</h2>\n<p><a href=\"https://angular.io/guide/component-interaction#parent-and-children-communicate-via-a-service\" target=\"_blank\" rel=\"noopener noreferrer\">Communication through data services</a> seems to be a pretty accepted practice in the <em>Angular</em> community. The gist of it is to define a service that belongs to a component up in the hierarchy, which is made available to the children without creating new instances. The service provides a number of methods to alter the state in a well defined way. Updates are fetched through <a href=\"https://angular.io/guide/observables\" target=\"_blank\" rel=\"noopener noreferrer\">observables</a>. This has a bunch of advantages:</p>\n<ul>\n<li>The logic to alter state is gathered in one place, outside of any component.</li>\n<li>The state can be only modified through this API, which makes it easier to control and understand changes.</li>\n<li>Anybody which is interested in getting updates regarding a certain subject can just subscribe to an observable. This decouples the actions from the reactions.</li>\n</ul>\n<p>A simple service could look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">@<span class=\"token function\">Injectable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TimeStore</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token keyword\">private</span> timeslotSubject <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BehaviorSubject</span><span class=\"token operator\">&lt;</span>Date<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  timeslot$ <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>timeslotSubject<span class=\"token punctuation\">.</span><span class=\"token function\">asObservable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">selectTimeslot</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">timeslot</span><span class=\"token operator\">:</span> Date</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>timeslotSubject<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>timeslot<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This is the most satisfying way of dealing with state I have found in <em>Angular</em> thus far. It allows you to decouple things pretty nicely, and it scales quite well if the number of components that are interested in certain updates increases. It is not <a href=\"https://blog.angular-university.io/how-to-build-angular2-apps-using-rxjs-observable-data-services-pitfalls-to-avoid/\" target=\"_blank\" rel=\"noopener noreferrer\">without caveats</a>, though. It tends to require a lot of boilerplate as well. But then again, <em>Angular</em> seems to require a lot of boilerplate code in general.</p>\n<p>Another important thing to remember is that you really have to avoid creating services without a good API, or even worse, with just some public fields. Otherwise you just created a semi-global mutable shared state. At that point, we might as well just define things in the global namespace (avoid that).</p>\n<h2>ngrx store</h2>\n<p><a href=\"https://github.com/ngrx/platform/blob/master/docs/store/README.md\" target=\"_blank\" rel=\"noopener noreferrer\">ngrx store</a> is the <em>Angular</em> equivalent to <em>redux</em>. Unlike the <em>React</em> community, it does not seem to be as an accepted as a state management solution, at least according to other developers I have talked with. I have not managed to use it for any real code thus far, although it decidedly looks like <em>redux</em>, maybe a bit more verbose. It has the same problem as <em>redux</em>, though: It is not easy to grasp as first. Introducing it to an inexperienced team can lead to a lot of blank looks.</p>\n<h2>Conclusion</h2>\n<p>My conclusion is that I do not have a conclusion. How do you deal with state in <em>Angular</em>? I do not feel a lot wiser now that some months ago. I have seen a lot of things I do not want to do, but it is not like I can offer a solid overarching strategy. My <strong>TL;DR</strong>  would be use <em>Data Services</em>, and hope for the best.</p>\n<p>These are my main points with <em>Angular</em> for now. I think I have other small points that I might compile into another entry, maybe.</p>","frontmatter":{"layout":"post","title":"Angular from the perspective of a React fan - Part 3","path":"/angular-from-react-part3/","categories":["JavaScript","React","Angular","TypeScript","angular-cli","redux"],"date":"2018/07/07","draft":false,"description":"Third part of my series on Angular, coming from a React background. This article focus on state management","canonical":null,"image":null}},"related":{"nodes":[]},"previous":{"frontmatter":{"title":"Playing with CSS Grid","path":"/playing-with-css-grid/","date":"2018/04/28"}},"next":{"frontmatter":{"title":"Angular from the perspective of a React fan - Part 2","path":"/angular-from-react-part2/","date":"2018/04/29"}}},"pageContext":{"related":[],"previous":"/playing-with-css-grid/","next":"/angular-from-react-part2/"}},"staticQueryHashes":[],"slicesMap":{}}